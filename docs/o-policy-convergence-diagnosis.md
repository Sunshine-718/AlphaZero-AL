# O 策略不收敛的根本原因诊断报告

> 日期：2026-02-23
> 工具：`tools/diagnose_mcts.py`
> 模型：`params/AZ_Connect4_CNN_current.pt`

## 问题描述

FPU 越界 bug 修复后，X 的第一步策略已正确收敛到 col3（最优开局）。但 O 的第一步策略（X 下 col3 之后）始终无法收敛到完美策略 col3，在 col2/col3/col4 之间反复跳动。

## 生产参数

| 参数 | 值 | 备注 |
|---|---|---|
| c_init | 1.0 | |
| c_base | 100,000 | C++ 实际值，Python 默认 500 |
| n_playout | 100 | 自对弈搜索预算 |
| discount | 1.0 | |
| alpha | 0.3 | Dirichlet noise |
| noise_eps | 0.25 | |
| fpu_reduction | 0.2 | |
| lambda_s | 0.1 | 步数衰减系数 |

## 诊断结果

### 1. NN 对 O 子节点的评估方向是反的

对 O 的局面（X 下 col3 之后），逐一模拟 O 下 col0~col6，用 NN 评估结果局面：

| O 的选择 | -V (O 视角) | P1win% | Draw% | P2win% | E[steps] | Prior |
|---|---|---|---|---|---|---|
| col0 | -0.0944 | 56.2 | 26.5 | 17.3 | 31.1 | 5.2% |
| col1 | -0.1556 | 58.3 | 26.0 | 15.7 | 31.3 | 8.3% |
| **col2** | **-0.3958** | **63.5** | **23.1** | **13.4** | **32.4** | **25.4%** |
| **col3** | **-0.6065** | **82.8** | **8.3** | **8.8** | **33.4** | **26.2%** |
| **col4** | **-0.3878** | **63.4** | **23.3** | **13.3** | **32.0** | **27.0%** |
| col5 | -0.1519 | 58.1 | 26.2 | 15.7 | 31.3 | 5.2% |
| col6 | -0.0581 | 53.8 | 28.7 | 17.5 | 30.9 | 2.7% |

**关键发现**：NN 认为 O-col3 → P1win=82.8%（X 赢面最大），即 O 下 col3 是**最差选择**。这与游戏理论完全相反——col3 应该是 O 的最佳防守。

中心列差异（-V，越高越好）：
- col2 - col3 = **+0.2107**（NN 认为 col2 远好于 col3）
- col2 - col4 = **-0.0080**（col2 ≈ col4）
- col3 - col4 = **-0.2187**（NN 认为 col3 远差于 col4）

### 2. 聚合 MCTS 统计（30 次运行，n=100）

| col | N_mean | N% | Q_mean | -Q_mean |
|---|---|---|---|---|
| col0 | 2.5 | 2.5% | -0.1012 | +0.1012 |
| col1 | 4.1 | 4.1% | -0.1429 | +0.1429 |
| col2 | 27.3 | 27.3% | -0.3312 | +0.3312 |
| col3 | 24.2 | 24.2% | -0.2975 | +0.2975 |
| col4 | 30.6 | 30.6% | -0.3413 | +0.3413 |
| col5 | 6.7 | 6.7% | -0.1544 | +0.1544 |
| col6 | 1.5 | 1.5% | -0.0779 | +0.0779 |

**Signal-to-noise 分析**：
- Q(col2) - Q(col3) = -0.0337, noise=0.0498, **SNR=0.676** — 信号被噪声淹没
- Q(col3) - Q(col4) = +0.0438, noise=0.0312, **SNR=1.407** — 弱信号，方向是 col4 > col3

MCTS 在 n=100 时 col4 的 Q 值最高（+0.3413），col2 次之（+0.3312），col3 最低（+0.2975）。这完全是被 NN 的错误 value 评估主导的结果。

### 3. 模拟次数扫描

| n | col0 | col1 | col2 | col3 | col4 | col5 | col6 |
|---|---|---|---|---|---|---|---|
| 100 | 2.7% | 3.4% | 26.3% | **28.5%** | 27.7% | 7.3% | 4.2% |
| 400 | 0.2% | 0.5% | **38.3%** | 11.4% | 36.3% | 12.1% | 1.3% |
| 1600 | 0.0% | 0.0% | **44.6%** | 5.8% | 44.2% | 5.5% | 0.0% |

**关键发现**：模拟次数越多，col3 的占比越**低**（28.5% → 11.4% → 5.8%）。

这证明 MCTS 越充分地利用 NN 的评估，结果越远离正确答案。问题出在 NN 本身，不是搜索深度。

### 4. Noise 消融实验

| 模式 | col2 | col3 | col4 |
|---|---|---|---|
| 有 noise (eps=0.25) | 26.1% | 25.9% | 28.3% |
| 无 noise (确定性) | 26.8% | 24.1% | 30.1% |

Dirichlet noise 实际上**帮助了** col3（从 24.1% 提升到 25.9%），因为 noise 增加了探索。但不足以翻转排序。

### 5. 纯 MCTS 对比（UCT + random rollout，无 NN）

#### X 空棋盘（ply=1）

| playout | col0 | col1 | col2 | **col3** | col4 | col5 | col6 |
|---|---|---|---|---|---|---|---|
| 1,000 | 12.2% | 14.3% | 16.6% | **19.2%** | 12.6% | 11.8% | 13.2% |
| 10,000 | 10.4% | 13.8% | 13.3% | **27.5%** | 13.7% | 10.5% | 10.9% |
| 50,000 | 7.6% | 10.2% | 13.8% | **33.8%** | 15.7% | 10.7% | 8.2% |

纯 MCTS 正确识别 col3 为 X 的最优开局，且信号随 playout 增大而显著增强。

#### O 局面（X 下 col3 后，ply=2）

| playout | col0 | col1 | col2 | **col3** | col4 | col5 | col6 |
|---|---|---|---|---|---|---|---|
| 1,000 | 15.2% | 11.7% | **18.4%** | 16.3% | 13.9% | 13.7% | 10.7% |
| 10,000 | 10.7% | 14.9% | 13.4% | 17.2% | **17.6%** | 14.6% | 11.5% |
| 50,000 | 9.2% | 14.2% | 19.0% | **19.5%** | 16.2% | 12.2% | 9.6% |

**关键发现**：
- n=50,000 时 col3 才**勉强**成为最优：col3=19.5% (Q=-0.219) vs col2=19.0% (Q=-0.223)
- Q 差仅 **0.004**，访问差仅 **0.5 个百分点**
- n=10,000 时 col4 反而排第一
- 与 X 的 col3 信号（33.8%，遥遥领先）形成鲜明对比

### 6. 纯 MCTS c_init 扫描（UCT + random rollout）

探索常数 c_init 对纯 MCTS 能否识别 col3 的影响。c_init 越小 = 越偏重 exploitation。

#### X 空棋盘 — col3 visit%

| c_init | n=1,000 | n=10,000 | n=50,000 |
|---|---|---|---|
| **1** | **52.4%** | **42.6%** | **55.6%** |
| 2 | 22.0% | 39.1% | 45.3% |
| 4 | 16.5% | 29.6% | 34.0% |
| 8 | 15.4% | 21.4% | 26.2% |
| 16 | 15.7% | 17.9% | 20.9% |

X 的 col3 信号强，所有 c_init 都能识别，但低 c_init 收敛更快。

#### O 局面 — col3 visit%

| c_init | n=1,000 | n=10,000 | n=50,000 |
|---|---|---|---|
| **1** | 17.1% | **29.8%** | **42.9%** |
| 2 | 15.3% | 20.3% | 25.5% |
| 4 | 14.6% | 16.2% | 22.2% |
| 8 | 14.8% | 16.1% | 17.8% |
| 16 | 14.2% | 15.7% | 16.9% |

**关键发现**：
- **c_init=1, n=50,000 时 O-col3 达到 42.9%**，遥遥领先 col2=13.7%
- 低 c_init（少探索、重 exploitation）反而更快收敛到正确答案——弱信号需要深度搜索来放大
- 高 c_init（c=16）使信号几乎消失（16.9%，接近均匀 14.3%）
- 纯 MCTS 在 c=1 + n=50,000 可以明确识别 O-col3，完全独立于 NN

### 7. AZ MCTS 超参扫描（带 NN，n=100）

固定其他参数为生产值，单独扫描 c_init / alpha / fpu_reduction，观察对 O 局面 col3 visit% 的影响。

#### c_init sweep（alpha=0.3, fpu=0.2）

| c_init | col3 visit% | -Q |
|---|---|---|
| 0.1 | **40.4%** | -0.794 |
| 0.3 | 30.1% | -0.716 |
| 0.5 | 28.8% | -0.699 |
| 1.0 (生产) | 26.1% | -0.678 |
| 2.0 | 26.7% | -0.681 |

c_init=0.1 时 col3 达到 40.4%，但完全是靠 prior（26.2%）被放大，**Q 值方向仍然是错的**（-Q 为负）。

#### alpha sweep（c_init=1.0, fpu=0.2）

| alpha | col3 visit% |
|---|---|
| 0.03 | 28.0% |
| 0.1 | 26.5% |
| 0.3 (生产) | 27.1% |
| 0.7 | 27.8% |
| 1.55 | 26.7% |

**alpha 几乎没有影响**，col3 在 26-28% 之间浮动。Dirichlet noise 的强度不是瓶颈。

#### fpu_reduction sweep（c_init=1.0, alpha=0.3）

| fpu | col3 visit% |
|---|---|
| 0.0 | 26.6% |
| 0.1 | 26.1% |
| 0.2 (生产) | 27.3% |
| 0.4 | 29.3% |
| 0.8 | 27.6% |

**FPU 也几乎没有影响**，col3 在 26-29% 之间浮动。

#### 超参扫描小结

- **c_init 是唯一有显著影响的参数**，但它只是改变 prior 与 Q 的相对权重，不修正 Q 本身
- **alpha 和 FPU 无显著影响**
- **所有配置下 Q 值方向始终是错的**（O-col3 的 -Q 始终为负）

### 8. 纯 MCTS 超参扫描（PUCT + uniform prior + random rollout）

使用 MCTS_AZ 框架但用 random rollout 代替 NN，测试 PUCT 选择 + Dirichlet noise + FPU 在无 NN 偏差时的表现。

（部分结果，n=5000, 20 runs）

#### X 空棋盘

| 参数 | 值 | col3 visit% |
|---|---|---|
| c_init=0.1 | (alpha=None, fpu=0) | 35.4% |
| c_init=0.5 | | 57.7% |
| c_init=1.0 | | **79.4%** |
| c_init=2.0 | | 75.8% |
| alpha=0.03 | (c_init=4, fpu=0) | 73.0% |
| alpha=1.55 | | 74.8% |

X 的 col3 在所有配置下都非常强势，alpha 对 X 几乎没有影响。

## 根因分析

### 自强化 Bootstrap 陷阱

```
NN 认为 O-col3 差
        ↓
MCTS 在 n=100 时减少 col3 的访问
        ↓
自对弈数据中 O-col3 路径被低估
        ↓
训练数据缺乏 O-col3 的正面样本
        ↓
NN 进一步强化 "O-col3 差" 的评估
        ↓
（循环）
```

### 为什么这个问题只出现在 O 的开局？

1. **X 的 col3 信号强**：纯 MCTS n=5000 就能看出 col3 遥遥领先（23.2%），AlphaZero 在 n=100 足够学到
2. **O 的 col3 信号极弱**：纯 MCTS n=50,000 才勉强分出（19.5% vs 19.0%），n=100 根本看不到
3. **NN 放大了错误方向**：本来只是"分不出"，但 NN 学到了相反方向，然后 MCTS 越搜索越偏

### 为什么调超参解决不了？

**完整的超参扫描**（Section 6-8）证明：

- **纯 MCTS 的 c_init**：低 c_init（更多 exploitation）让纯 MCTS 更快收敛到 col3，但 O 的信号仍需 n=50,000 才清晰。AZ MCTS 中 c_init 只改变 prior 与 Q 的权重，不修正 Q 方向
- **Dirichlet alpha**：从 0.03 到 1.55，col3 visit% 在 26-28% 之间浮动，几乎无影响
- **FPU reduction**：从 0.0 到 0.8，col3 visit% 在 26-29% 之间浮动，几乎无影响
- **核心矛盾**：这些参数都只影响**搜索过程中的访问分布**，但无法修正 NN value head 学到的**错误 Q 值方向**。即使 col3 被访问更多次，NN 仍然给出负面评价，Q 值仍然指向错误方向

### 为什么 lambda_s 解决不了？

lambda_s 公式：`value = (1-λ) × value_base - λ × sign(value_base) × steps_adjusted`

- **value_base 差距** ≈ 0.38（col3 比 col2 差了 20pp 的 P1win）
- **steps 差距** ≈ 1 步 / 43 步 ≈ 0.023（归一化后）

要翻转排序需要 `λ × 0.023 > (1-λ) × 0.38`，即 **λ > 0.94**。

此外 steps head 本身也受自对弈偏差影响，用有偏的 head 修正有偏的 head 无效。

## 解决方案

### 推荐：开局随机化（Opening Diversification）

在自对弈中，以一定概率（如 25%）对前 K 步使用均匀随机选择。

- **原理**：强制训练数据覆盖所有开局路径，包括 O-col3
- **代价**：实现简单，几乎无速度代价
- **先例**：KataGo 和 Leela Zero 均采用类似方法
- **修改点**：`src/game.py` 的 `batch_self_play` 方法

### 备选方案

| 方案 | 效果 | 代价 |
|---|---|---|
| 加大 n_playout (100→800) | 纯 MCTS 50000 才分出，NN 辅助下可能 400-800 够 | 速度降 4-8x |
| Playout Cap Randomization | KataGo 验证有效 | 实现较复杂 |
| 外部 solver 注入 | 直接提供正确标签 | 需要额外工具 |

## 可视化

诊断图表保存在 `tools/figures/` 目录：

| 文件 | 内容 |
|---|---|
| `mcts_child_values.png` | NN 对各子节点的 value 评估柱状图 |
| `mcts_q_vs_visits.png` | Q 值 vs 访问次数散点图（含误差棒） |
| `sim_budget_sweep.png` | 模拟次数扫描：col3 随 n 增大而下降 |
| `noise_ablation.png` | Dirichlet noise 消融对比 |
| `multi_ply.png` | 多步深入分析（ply 1-4） |
| `pure_mcts_comparison.png` | AlphaZero MCTS vs 纯 MCTS 对比 |
| `pure_mcts_c_sweep.png` | 纯 MCTS c_init × n_playout 热力图 |
| `az_hp_sweep.png` | AZ MCTS 超参扫描（c_init / alpha / fpu） |
| `pure_mcts_hp_sweep.png` | 纯 MCTS 超参扫描（PUCT + rollout） |

## 复现

```bash
# 完整诊断（约 10 分钟）
python tools/diagnose_mcts.py

# 快速模式（约 2 分钟）
python tools/diagnose_mcts.py --quick

# 仅纯 MCTS c_init 扫描
python tools/diagnose_mcts.py --pure-only

# 仅纯 MCTS 超参扫描（PUCT + rollout，c_init / alpha / fpu）
python tools/diagnose_mcts.py --hp-only

# 快速模式
python tools/diagnose_mcts.py --pure-only --quick
python tools/diagnose_mcts.py --hp-only --quick
```
